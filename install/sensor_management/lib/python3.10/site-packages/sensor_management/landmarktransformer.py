import rclpy
from rclpy.node import Node
import numpy as np
from nav_msgs.msg import Odometry
from messages.msg import LineSegmentList, LineSegment
from visualization_msgs.msg import Marker, MarkerArray
from geometry_msgs.msg import Point
from tf_transformations import euler_from_quaternion

class landmarktransformer(Node):
    def __init__(self):
        super().__init__('landmarktransformer')
        self.subscription = self.create_subscription(
            LineSegmentList,
            '/extracted_lines',  # Input topic from ls_extraction
            self.line_callback,
            10)
        self.odom_subscription = self.create_subscription(
            Odometry,
            '/odom',  # Input topic for fused odometry
            self.odom_callback,
            10)
        self.publisher = self.create_publisher(LineSegmentList, '/transformed_lines', 10)
        self.marker_publisher = self.create_publisher(MarkerArray, '/landmark_markers', 10)
        self.current_pose = None

    def odom_callback(self, msg):
        """Updates the robot's current pose from odometry."""
        orientation_q = msg.pose.pose.orientation
        orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
        _, _, theta_r = euler_from_quaternion(orientation_list)
        
        self.current_pose = np.array([
            [np.cos(theta_r), -np.sin(theta_r), msg.pose.pose.position.x],
            [np.sin(theta_r), np.cos(theta_r), msg.pose.pose.position.y],
            [0, 0, 1]
        ])

    def line_callback(self, msg):
        """Transforms line segments from the Lidar frame to the world frame."""
        if self.current_pose is None:
            self.get_logger().warn("No odometry data received yet!")
            return

        transformed_lines = LineSegmentList()
        transformed_lines.header = msg.header  # Preserve timestamp

        marker_array = MarkerArray()
        marker_id = 0

        for line in msg.segments:
            start = np.array([[line.start.x], [line.start.y], [1]])
            end = np.array([[line.end.x], [line.end.y], [1]])
            
            transformed_start = self.current_pose @ start
            transformed_end = self.current_pose @ end
            
            transformed_line = LineSegment()
            transformed_line.start.x = transformed_start[0, 0]
            transformed_line.start.y = transformed_start[1, 0]
            transformed_line.end.x = transformed_end[0, 0]
            transformed_line.end.y = transformed_end[1, 0]
            transformed_line.alpha = line.alpha  # Angle should remain the same in the world frame
            transformed_line.rho =  line.rho  # Keep radius relative
            transformed_line.covariance = line.covariance  # Keep covariance unchanged
            
            transformed_lines.segments.append(transformed_line)
            
            # Create visualization marker
            marker = Marker()
            marker.header = msg.header
            marker.ns = "landmarks"
            marker.id = marker_id
            marker.type = Marker.LINE_STRIP
            marker.action = Marker.ADD
            marker.scale.x = 0.05  # Line width
            marker.color.r = 1.0
            marker.color.g = 0.0
            marker.color.b = 0.0
            marker.color.a = 1.0  # Fully visible
            marker.pose.orientation.w = 1.0
            marker.points = [self.create_point(transformed_start[0, 0], transformed_start[1, 0]),
                             self.create_point(transformed_end[0, 0], transformed_end[1, 0])]
            marker_array.markers.append(marker)
            marker_id += 1

        self.publisher.publish(transformed_lines)
        self.marker_publisher.publish(marker_array)

    def create_point(self, x, y):
        """Creates a geometry_msgs/Point object."""
        p = Point()
        p.x = x
        p.y = y
        p.z = 0.0
        return p

def main(args=None):
    rclpy.init(args=args)
    node = landmarktransformer()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
